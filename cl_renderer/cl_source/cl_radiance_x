// cl_radiance /////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "rt_parameters.h"



static void			radiance_add(
					constant t_scene *scene,
					global t_camera *camera,
					t_intersection *intersection,
					global RT_F4 *sample,
					constant t_cl_renderer_settings *settings,
					global ulong *rng_state)
{
	RT_F4			radiance;
	RT_F4			light;
	RT_F4			mask;
	RT_F			cosine;
	RT_F			choice;

	radiance = (RT_F4){0.f, 0.f, 0.f, 1.f};
	mask = 1;
	for (int depth = 0; depth < settings->sample_depth; depth++)
	{
		if (!scene_intersect(scene, intersection, settings))
    		break;

		if (depth > settings->sample_depth / 2 + 1 && f4_max_component(intersection->material.color) < rng(rng_state))
			break ;

		radiance += mask * intersection->material.emission;

		if (settings->light_basic)
		{
			light = light_basic(scene, intersection, settings, camera->filter_cartoon);
            radiance += light * mask;
		}

		if (settings->light_area)
		{
			light = light_area(scene, intersection, settings, rng_state);
			radiance += light * mask * intersection->material.color;
		}

        if (f4_max_component(intersection->material.reflectance) > 0.|| f4_max_component(intersection->material.transparence) > 0.)
        {
            choice = rng(rng_state);
            if (choice < intersection->material.reflectance)
                intersection_reflect(intersection, intersection);
            else
                intersection_refract(intersection, intersection);
            mask /= choice < intersection->material.reflectance ? 1 : intersection->material.transparence;
        }
        else
		{
		    intersection->ray.origin = intersection->hit;

		    intersection->ray.direction = sample_uniform(&intersection->normal, &cosine, rng_state);
		    mask *= intersection->material.color * cosine;
        }
	}

	if (settings->sample_count == 1)
		*sample = radiance;
	else
		*sample += radiance;
}

static RT_F4		radiance_get(
					global RT_F4 *sample,
					constant t_cl_renderer_settings *settings)
{
	return (*sample / settings->sample_count);
}
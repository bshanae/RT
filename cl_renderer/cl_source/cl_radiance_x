// cl_radiance /////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "rt_parameters.h"

#define FT_ABS(x) x < 0 ? x * -1 : x

static RT_F4					test(
                                constant t_scene *scene,
                                constant t_camera *camera,
                                t_intersection *intersection)
{
    constant t_object_sphere	*sphere;
    RT_F						x;
    RT_F4						k;
    RT_F4						tmp;
    RT_F4						illumination;
    int gi = get_global_id(0);

    illumination = 0.;
    for (int i = 0; i < scene->objects_length; i++)
    {
        if (scene->objects[i].type != object_sphere)
            continue ;
        if (f4_max_component(scene->objects[i].material.emission) == 0.f)
            continue ;
        sphere = (constant t_object_sphere	*)scene->objects[i].data;
        k = intersection->ray.direction - normalize(sphere->position - intersection->ray.origin);
        x = dot(intersection->ray.origin - sphere->position, normalize(k));
        illumination += (RT_F)(0.2 * sphere->radius / (FT_ABS(x))) * scene->objects[i].material.emission;
    }
    return ((RT_F4){FT_ABS(illumination.x), FT_ABS(illumination.y), FT_ABS(illumination.z), 0.});
}

static void			radiance_add(
                    constant t_camera *camera,
					constant t_scene *scene,
					t_intersection *intersection,
					global RT_F4 *sample,
					constant t_cl_renderer_settings *settings,
					global ulong *rng_state,
					int global_id)
{
	RT_F4			radiance;
	RT_F4			explicit;
	RT_F4			mask;
	RT_F			cosine;
	RT_F			choice;

	radiance = (RT_F4){0.f, 0.f, 0.f, 0.f};
	mask = (RT_F4){1.f, 1.f, 1.f, 1.f};
	for (int depth = 0; depth < settings->sample_depth; depth++)
	{

		if (!scene_intersect(scene, intersection, settings))
			break;
		if (depth > settings->russian_depth && f4_max_component(intersection->material.color) < rng(rng_state))
			break ;

		if (depth == 0)
        {
            explicit = test(scene, camera, intersection);
            radiance += explicit;
        }

		if (intersection->material.reflection || intersection->material.refraction)
		{
			choice = rng(rng_state);
			if (choice < intersection->material.reflection)
				intersection_reflect(intersection, intersection);
			else
				intersection_refract(intersection, intersection);
			mask = mask / (choice < intersection->material.reflection ? 1 : intersection->material.refraction);
		}
		else
		{
			radiance += mask * intersection->material.emission;
			if (settings->light_explicit)
			{
				explicit = radiance_explicit(scene, intersection, settings, rng_state);
				radiance += explicit * mask * intersection->material.color;
			}

#ifdef RT_CL_UNIFORM
			intersection->ray.direction = sample_uniform(&intersection->normal, &cosine, rng_state);
			mask *= intersection->material.color * cosine;
#endif

#ifdef RT_CL_COSINE
			intersection->ray.direction = sample_cosine(&intersection->normal, rng_state);
			mask *= intersection->material.color;
#endif
			intersection->ray.origin = intersection->hit;
		}
	}

	if (settings->sample_count == 1)
		*sample = radiance;
	else
		*sample += radiance;
}

static RT_F4		radiance_get(
					global RT_F4 *sample,
					constant t_cl_renderer_settings *settings)
{
	return (*sample / settings->sample_count);
}